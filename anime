#!/usr/bin/env python3

import requests
import subprocess
import re
import sys
import sqlite3
from bs4 import BeautifulSoup
import os
import time
import argparse
from collections import OrderedDict

# ===== COULEURS ANSI =====
RED = R = '\033[91m'
GREEN = G = '\033[92m'
YELLOW = Y = '\033[93m'
BLUE = B = '\033[94m'
MAGENTA = M = '\033[95m'
CYAN = C = '\033[96m'
WHITE = W = '\033[97m'
RESET = X = '\033[0m'
BOLD = '\033[1m'

# Version du programme
__version__ = "2.0.0"

# Configuration
MAX_CACHE_SIZE = 100
CACHE_TTL = 900
MAX_RETRIES = 3
REQUEST_TIMEOUT = 10

# Site de base
BASE_URL = "https://anime-sama.tv"

# Pre-compiled regex patterns
PANNEAU_PATTERN = re.compile(r'panneauAnime\("([^"]+)",\s*"([^"]+)"\)')
EPISODE_FILEVER_PATTERN = re.compile(r'episodes\.js\?filever=(\d+)')

def show_banner():
    sys.stdout.write('\033[2J\033[H')
    sys.stdout.flush()
    print()
    print(BOLD + CYAN + "  üé¨ ANIME-SAMA-CLI" + RESET + CYAN + " v" + __version__ + RESET)
    print(GREEN + "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" + RESET)
    print(YELLOW + "  üí° --vf" + RESET + " = VF only  |  " + YELLOW + "--clear-history" + RESET + " = R√©initialiser l'historique")
    print(CYAN + "  üìñ -h" + RESET + " for more help")
    print()

def check_deps():
    print(BLUE + "üîç V√©rification des d√©pendances..." + RESET)
    missing = []

    def check_command(cmd, name):
        try:
            result = subprocess.run([cmd, "--version"], capture_output=True, timeout=3, text=True)
            if result.returncode == 0:
                print(GREEN + f"  ‚úì {name}" + RESET)
                return True
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.CalledProcessError):
            pass
        missing.append(name)
        print(RED + f"  ‚úó {name}" + RESET)
        return False

    check_command("fzf", "fzf")

    try:
        import requests
        print(GREEN + f"  ‚úì requests" + RESET)
    except ImportError:
        missing.append("python-requests")
        print(RED + "  ‚úó requests" + RESET)

    try:
        import bs4
        print(GREEN + f"  ‚úì beautifulsoup4" + RESET)
    except ImportError:
        missing.append("python-beautifulsoup4")
        print(RED + "  ‚úó beautifulsoup4" + RESET)

    if missing:
        print(f"\n{RED}‚ùå D√©pendances manquantes: {', '.join(missing)}{RESET}")
        die("D√©pendances critiques manquantes")

    print(GREEN + "  ‚úì Pr√™t!" + RESET)
    print()

HEADERS_BASE = {
    "user-agent": "Mozilla/5.0 (X11; Linux x86_64; rv:134.0) Gecko/20100101 Firefox/134.0",
    "accept-language": "fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7",
    "connection": "keep-alive"
}

def fzf_select(items, prompt="S√©lectionner: ", multi=False):
    if not items:
        return None

    if len(items) == 1:
        return items[0]

    fzf_input = "\n".join(items)
    cmd = ["fzf", "--reverse", "--cycle", f"--prompt={prompt}"]
    if multi:
        cmd.append("-m")

    try:
        result = subprocess.run(
            cmd,
            input=fzf_input,
            text=True,
            capture_output=True
        )

        if result.returncode == 0:
            selected = result.stdout.strip()
            if multi:
                return selected.split('\n') if selected else []
            return selected
        return None
    except FileNotFoundError:
        print(RED + "‚úó fzf non trouv√©! Installez fzf." + RESET)
        return None
    except Exception as e:
        print(RED + f"‚úó Erreur de s√©lection: {e}" + RESET)
        return None

def die(message, suggestion=None):
    print(f"\r{RED}‚úó {message}{RESET}", file=sys.stderr)
    if suggestion:
        print(f"{YELLOW}üí° Suggestion: {suggestion}{RESET}", file=sys.stderr)
    sys.exit(1)

def search_prompt():
    while True:
        try:
            query = input(f"\033[1;36mRechercher un anime: \033[0m").strip()
            if query:
                return query
        except (EOFError, KeyboardInterrupt):
            print()
            sys.exit(0)

def get_db_path():
    db_dir = os.path.expanduser("~/.local/share/anime-cli")
    os.makedirs(db_dir, exist_ok=True)
    return os.path.join(db_dir, "history.db")

def init_db():
    with sqlite3.connect(get_db_path()) as conn:
        cursor = conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            anime_name TEXT NOT NULL,
            episode_number INTEGER NOT NULL,
            saison TEXT NOT NULL,
            url TEXT NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(anime_name, saison, episode_number)
        )
        ''')
        conn.commit()

def clear_history():
    try:
        init_db()
        with sqlite3.connect(get_db_path()) as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM history")
            conn.commit()
        print(GREEN + "‚úì Historique supprim√©" + RESET)
    except Exception as e:
        die(f"Erreur suppression historique: {e}")

def get_watched_episodes(anime_name, saison):
    """R√©cup√®re la liste des √©pisodes d√©j√† regard√©s"""
    try:
        init_db()
        with sqlite3.connect(get_db_path()) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT episode_number FROM history WHERE anime_name = ? AND saison = ?",
                (anime_name, saison)
            )
            return {row[0] for row in cursor.fetchall()}
    except Exception as e:
        print(YELLOW + f"‚ö† Erreur lecture historique: {e}" + RESET)
        return set()

def get_last_watched_episode(anime_name, saison):
    """R√©cup√®re le dernier √©pisode regard√©"""
    try:
        init_db()
        with sqlite3.connect(get_db_path()) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT episode_number FROM history WHERE anime_name = ? AND saison = ? ORDER BY timestamp DESC LIMIT 1",
                (anime_name, saison)
            )
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        return None

def add_to_history(anime_name, episode_number, saison, url):
    try:
        init_db()
        with sqlite3.connect(get_db_path()) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "INSERT OR REPLACE INTO history (anime_name, episode_number, saison, url, timestamp) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)",
                (anime_name, episode_number, saison, url)
            )
            conn.commit()
            print(GREEN + "‚úì Historique mis √† jour" + RESET)
    except Exception as e:
        print(YELLOW + f"‚ö† Erreur historique: {e}" + RESET)

class AnimeDownloader:
    def __init__(self, debug=False):
        self.session = requests.Session()
        self.session.headers.update(HEADERS_BASE)
        self.debug = debug
        self._cache = OrderedDict()
        self._cache_ttl = CACHE_TTL

    def debug_print(self, *args, **kwargs):
        if self.debug:
            print("[DEBUG]", *args, **kwargs)

    def _get_cache_key(self, url, params=None):
        key = url
        if params:
            sorted_params = sorted(params.items()) if isinstance(params, dict) else params
            key += str(sorted_params)
        return key

    def _is_cache_valid(self, timestamp):
        return time.time() - timestamp < self._cache_ttl

    def _cached_request(self, method, url, **kwargs):
        cache_key = self._get_cache_key(url, kwargs.get('params'))

        if cache_key in self._cache:
            cached_data, timestamp = self._cache[cache_key]
            if self._is_cache_valid(timestamp):
                self.debug_print(f"Cache hit pour {url[:50]}...")
                return cached_data

        for attempt in range(MAX_RETRIES):
            try:
                response = getattr(self.session, method.lower())(url, timeout=REQUEST_TIMEOUT, **kwargs)
                response.raise_for_status()

                self._cache[cache_key] = (response, time.time())
                self._cache.move_to_end(cache_key)

                if len(self._cache) > MAX_CACHE_SIZE:
                    self._cache.popitem(last=False)

                return response

            except requests.exceptions.Timeout:
                if attempt < MAX_RETRIES - 1:
                    self.debug_print(f"Timeout tentative {attempt + 1}, nouvelle tentative...")
                    time.sleep(1)
                    continue
                raise
            except requests.exceptions.RequestException as e:
                if attempt < MAX_RETRIES - 1 and "Connection" in str(e):
                    self.debug_print(f"Erreur de connexion tentative {attempt + 1}, nouvelle tentative...")
                    time.sleep(2)
                    continue
                raise

    def get_catalogue(self, query="", vf=False):
        try:
            url = f"{BASE_URL}/catalogue/"
            headers = {
                **HEADERS_BASE,
                "host": "anime-sama.tv",
                "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
                "referer": f"{BASE_URL}/catalogue/",
            }
            querystring = {}
            if query:
                querystring["search"] = query
            if vf:
                querystring["langue[]"] = "VF"

            self.debug_print(f"GET request to: {url}")
            self.debug_print(f"Querystring: {querystring}")

            response = self._cached_request('get', url, headers=headers, params=querystring)

            self.debug_print(f"Status code: {response.status_code}")

            soup = BeautifulSoup(response.text, 'html.parser')
            animes = []
            urls = []

            for card in soup.find_all('a', href=True):
                titre = None
                titre_tag = card.find('h2')
                if not titre_tag:
                    titre_tag = card.find('h1', class_='text-white')

                if titre_tag:
                    titre = titre_tag.text.strip()

                if titre and '/catalogue/' in card['href']:
                    animes.append(titre)
                    full_url = card['href']
                    if not full_url.startswith('http'):
                        full_url = BASE_URL + full_url
                    urls.append(full_url)

            if vf:
                urls = [link.replace("vostfr", "vf") for link in urls]

            self.debug_print(f"Trouv√© {len(animes)} titres")
            self.debug_print(f"Titres: {animes[:5]}")

            return animes, urls
        except requests.RequestException as e:
            print(f"Erreur: {str(e)}")
            self.debug_print(f"Exception compl√®te: {str(e)}")
            return [], []

    def get_seasons(self, html_content):
        seasons = []
        matches = PANNEAU_PATTERN.findall(html_content)
        if not matches:
            return []
        for name, path in matches:
            if "film" not in name.lower() and name.lower() != "nom":
                seasons.append({
                    'name': name,
                    'url': path
                })
        return seasons

    def get_episode_list(self, url):
        headers = {
            "host": "anime-sama.tv",
            "user-agent": "Mozilla/5.0 (X11; Linux x86_64; rv:134.0) Gecko/20100101 Firefox/134.0",
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "accept-language": "fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7",
            "connection": "keep-alive",
        }
        try:
            response = self._cached_request('get', url, headers=headers)
            content = response.text
            match = EPISODE_FILEVER_PATTERN.search(content)
            if match:
                return match.group(1)
            return None
        except Exception as e:
            print(f"Erreur: {str(e)}")
            return None

    def get_anime_episode(self, complete_url, filever):
        url = f"{complete_url}/episodes.js"
        try:
            response = self._cached_request('get', url, params={"filever": filever})
            content = response.text

            all_links = {}

            # Rechercher les patterns Sibnet et Vidmoly
            sibnet_matches = list(re.finditer(r'https://video\.sibnet\.ru/shell\.php\?videoid=(\d+)', content))
            vidmoly_matches = list(re.finditer(r'https://vidmoly\.(?:to|net)/embed-([^.]+)\.html', content))

            if sibnet_matches:
                self.debug_print(f"Trouv√© {len(sibnet_matches)} √©pisodes Sibnet")
                for i, match in enumerate(sibnet_matches, 1):
                    video_id = match.group(1)
                    episode_name = f"Episode {i}"
                    all_links[str(i)] = ('sibnet', video_id, episode_name)
            elif vidmoly_matches:
                self.debug_print(f"Trouv√© {len(vidmoly_matches)} √©pisodes Vidmoly")
                for i, match in enumerate(vidmoly_matches, 1):
                    video_id = match.group(1)
                    episode_name = f"Episode {i}"
                    all_links[str(i)] = ('vidmoly', video_id, episode_name)

            if all_links:
                max_ep = max([int(k) for k in all_links.keys()])
                service_type = list(all_links.values())[0][0] if all_links else "unknown"
                self.debug_print(f"Trouv√© {len(all_links)} √©pisodes (1-{max_ep}) utilisant {service_type}")
            else:
                self.debug_print("Aucun √©pisode trouv√©")

            return all_links
        except requests.RequestException as e:
            print(f"Erreur lors de la r√©cup√©ration des √©pisodes: {e}")
            return {}

    def get_video_url(self, video_data):
        try:
            if len(video_data) == 3:
                video_type, video_id, episode_name = video_data
                print(f"{B}üé¨ R√©cup√©ration: {M}{episode_name}{X} ({video_type}:{video_id})")
            else:
                video_type, video_id = video_data
                print(f"{B}üé¨ R√©cup√©ration vid√©o: {M}{video_type}:{video_id}{X}")

            if video_type == 'sibnet':
                return self._get_sibnet_url(video_id)
            elif video_type == 'vidmoly':
                return self._get_vidmoly_url(video_id)
            else:
                print(f"Type de vid√©o non support√©: {video_type}")
                return None

        except Exception as e:
            print(f"Erreur lors de la r√©cup√©ration de l'URL vid√©o: {e}")
            return None

    def _get_sibnet_url(self, video_id):
        try:
            url = f"https://video.sibnet.ru/shell.php"
            response = self.session.get(url, params={"videoid": video_id})
            response.raise_for_status()
            html_content = response.text
            print(f"{Y}üîç Analyse du contenu Sibnet...{X}")
            match = re.search(r'player\.src\(\[\{src: "/v/([^/]+)/', html_content)
            if match:
                video_hash = match.group(1)
                url_sibnet = f"https://video.sibnet.ru/v/{video_hash}/{video_id}.mp4"
                print(f"{G}‚úÖ URL Sibnet trouv√©e{X}")
                headers_sibnet = {
                    **HEADERS_BASE,
                    "range": "bytes=0-",
                    "accept-encoding": "identity",
                    "referer": "https://video.sibnet.ru/",
                }
                response_sibnet = self.session.get(url_sibnet, headers=headers_sibnet, allow_redirects=False)
                if response_sibnet.status_code == 302:
                    return response_sibnet.headers['Location']
                else:
                    print(f"Code de statut Sibnet inattendu: {response_sibnet.status_code}")
            else:
                print("Pattern Sibnet non trouv√© dans le HTML")
            return None
        except requests.RequestException as e:
            print(f"Erreur lors de la r√©cup√©ration de l'URL Sibnet: {e}")
            return None

    def _get_vidmoly_url(self, video_id):
        vidmoly_domains = ['vidmoly.net', 'vidmoly.to']

        for domain in vidmoly_domains:
            try:
                embed_url = f"https://{domain}/embed-{video_id}.html"
                print(f"{Y}üîç Extraction de l'URL HLS depuis {domain}...{X}")

                headers = {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:134.0) Gecko/20100101 Firefox/134.0',
                    'Referer': f'https://{domain}/'
                }
                response = self._cached_request('get', embed_url, headers=headers)
                html_content = response.text

                hls_patterns = [
                    r'sources:\s*\[\s*\{\s*file:\s*["\']([^"\']+\.m3u8[^"\']*)["\']',
                    r'file:\s*["\']([^"\']+\.m3u8[^"\']*)["\']',
                    r'"file"\s*:\s*"([^"]+\.m3u8[^"]*)"',
                    r'src:\s*["\']([^"\']+\.m3u8[^"\']*)["\']'
                ]

                for pattern in hls_patterns:
                    match = re.search(pattern, html_content, re.IGNORECASE | re.DOTALL)
                    if match:
                        video_url = match.group(1)
                        if video_url.startswith('//'):
                            video_url = 'https:' + video_url
                        elif not video_url.startswith('http'):
                            video_url = f"https://{video_url.lstrip('/')}"

                        print(f"{G}‚úÖ URL de streaming HLS trouv√©e{X}")
                        return video_url

                print(f"{Y}‚ö† Pas de HLS trouv√©, retour de l'URL d'int√©gration{X}")
                return embed_url

            except Exception as e:
                self.debug_print(f"Erreur avec {domain}: {e}")
                continue

        fallback_url = f"https://vidmoly.net/embed-{video_id}.html"
        print(f"{Y}üîç Utilisation du fallback Vidmoly...{X}")
        return fallback_url

def show_link_and_prompt(video_url, anime_name, episode_number, saison, season_url, episodes, ep_keys, current_index, downloader):
    """Affiche le lien et propose les options suivant/quitter"""
    print()
    print(GREEN + "=" * 60 + RESET)
    print(BOLD + CYAN + "üîó LIEN DE LECTURE (ctrl+click) : " + RESET)
    print()
    print(BOLD + YELLOW + video_url + RESET)
    print()
    print(GREEN + "=" * 60 + RESET)
    print()

    # Sauvegarder dans l'historique
    add_to_history(
        anime_name=anime_name,
        episode_number=episode_number,
        saison=saison,
        url=season_url
    )

    # Proposer les options
    has_next = current_index + 1 < len(ep_keys)

    if has_next:
        print(BOLD + YELLOW + "Options:" + RESET)
        print(f"  {GREEN}[n]{RESET} Episode suivant")
        print(f"  {RED}[q]{RESET} Quitter")
        print()

        try:
            choice = input(f"{CYAN}Votre choix (n/q): {RESET}").strip().lower()

            if choice == 'n':
                # Lire l'√©pisode suivant
                next_index = current_index + 1
                next_ep = ep_keys[next_index]
                next_video_data = episodes[next_ep]
                next_episode_number = int(next_ep)

                print(CYAN + f"üîÑ Chargement de l'√©pisode {next_ep}..." + RESET)

                next_video_url = downloader.get_video_url(next_video_data)
                if not next_video_url:
                    die("Impossible d'obtenir l'URL vid√©o")

                if next_video_url.startswith('//'):
                    next_video_url = 'https:' + next_video_url

                # R√©cursion pour continuer
                show_link_and_prompt(next_video_url, anime_name, next_episode_number, saison,
                                   season_url, episodes, ep_keys, next_index, downloader)
            else:
                print(GREEN + "‚úì Termin√©!" + RESET)
                sys.exit(0)

        except (EOFError, KeyboardInterrupt):
            print()
            print(GREEN + "‚úì Termin√©!" + RESET)
            sys.exit(0)
    else:
        print(YELLOW + "‚úì Dernier √©pisode de la saison!" + RESET)

def main():
    show_banner()
    check_deps()

    parser = argparse.ArgumentParser(
        description="ANIME-SAMA-CLI - Mode lien uniquement",
        add_help=False
    )
    parser.add_argument("query", nargs="*", help="Recherche")
    parser.add_argument("--vf", action="store_true", help="Rechercher uniquement en VF")
    parser.add_argument("--debug", action="store_true", help="Mode debug")
    parser.add_argument("-h", "--help", action="store_true", help="Afficher l'aide")
    parser.add_argument("--clear-history", action="store_true", help="Supprimer tout l'historique")

    args = parser.parse_args()

    if args.help:
        print(f"""
{BOLD}{CYAN}Usage:{RESET} anime-sama-cli [OPTIONS] [TERME_RECHERCHE]

{BOLD}Options:{RESET}
    --vf                Rechercher uniquement en VF (doublage fran√ßais)
    --debug             Activer le mode debug
    --clear-history     Supprimer l'historique
    -h, --help          Afficher cette aide

{BOLD}Exemples:{RESET}
    anime-sama-cli                      # Recherche interactive
    anime-sama-cli naruto               # Rechercher "naruto"
    anime-sama-cli --vf one piece       # Rechercher "one piece" en VF

{BOLD}Fonctionnalit√©s:{RESET}
    ‚Ä¢ Historique visuel : Les √©pisodes vus sont marqu√©s d'une ‚úì
    ‚Ä¢ Navigation automatique : Apr√®s chaque √©pisode, choix de continuer ou quitter
    ‚Ä¢ Mode lien uniquement : Affichage des liens de streaming
    ‚Ä¢ Support VF/VOSTFR : Filtrage par langue disponible

{BOLD}Notes:{RESET}
    ‚Ä¢ Les liens .m3u8 fonctionnent dans la plupart des navigateurs modernes
    ‚Ä¢ Historique stock√© dans ~/.local/share/anime-cli/history.db
        """)
        return

    # Clear history
    if args.clear_history:
        clear_history()
        sys.exit(0)

    query = " ".join(args.query) if args.query else ""

    if not query:
        query = search_prompt()

    print()
    print(BOLD + CYAN + f"‚ï≠‚îÄ üîç Recherche sur anime-sama.tv..." + RESET)
    print(CYAN + f"‚ï∞‚îÄ‚û§ " + YELLOW + f'Requ√™te: "{query}"' + RESET)

    try:
        downloader = AnimeDownloader(debug=args.debug)
        animes, urls = downloader.get_catalogue(query, vf=args.vf)
    except requests.exceptions.ConnectionError:
        die("√âchec de la connexion r√©seau")
    except requests.exceptions.Timeout:
        die("D√©lai de connexion d√©pass√©")
    except Exception as e:
        if args.debug:
            print(f"{RED}Debug: {str(e)}{RESET}")
        die("√âchec de la r√©cup√©ration du catalogue")

    if not animes:
        die("Aucun r√©sultat trouv√©")

    print()
    print(BOLD + CYAN + "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" + RESET)
    print(BOLD + CYAN + "‚ïë" + YELLOW + "    üìã R√âSULTATS DE RECHERCHE" + CYAN + "         ‚ïë" + RESET)
    print(BOLD + CYAN + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + RESET)

    display_items = []
    for i, anime in enumerate(animes):
        display_items.append(f"{i+1}. {anime}")

    if args.debug:
        print(f"[DEBUG] Items d'affichage: {display_items[:3]}...")
        print(f"[DEBUG] Appel de fzf_select avec {len(display_items)} items")

    selected_anime_str = fzf_select(display_items, "üîç S√©lectionner un anime: ")
    if not selected_anime_str:
        die("Aucun anime s√©lectionn√©")

    try:
        selected_index = int(selected_anime_str.split('.')[0]) - 1
        if selected_index < 0 or selected_index >= len(animes):
            die("S√©lection invalide")
    except (ValueError, IndexError):
        die("Format de s√©lection invalide")

    anime_name = animes[selected_index]
    anime_url = urls[selected_index]

    print(GREEN + f"‚úì {anime_name}" + RESET)

    response = downloader._cached_request('get', anime_url)
    seasons = downloader.get_seasons(response.text)

    if not seasons:
        die("Aucune saison trouv√©e")

    print(YELLOW + f"üé≠ {len(seasons)} saison(s) disponible(s)" + RESET)

    season_items = []
    for i, season in enumerate(seasons):
        season_items.append(f"{i+1}. {season['name']}")

    selected_season_str = fzf_select(season_items, "üé≠ S√©lectionner une saison: ")
    if not selected_season_str:
        die("Aucune saison s√©lectionn√©e")

    try:
        season_index = int(selected_season_str.split('.')[0]) - 1
        if season_index < 0 or season_index >= len(seasons):
            die("S√©lection de saison invalide")
    except (ValueError, IndexError):
        die("Format de s√©lection de saison invalide")

    selected_season = seasons[season_index]

    # Construire l'URL de la saison
    season_path = selected_season['url']
    if not season_path.startswith('http'):
        if season_path.startswith('/'):
            season_url = BASE_URL + season_path
        else:
            season_url = anime_url.rstrip('/') + '/' + season_path.lstrip('/')
    else:
        season_url = season_path

    if args.vf:
        season_url = season_url.replace("vostfr", "vf")

    if args.debug:
        print(f"[DEBUG] URL de la saison: {season_url}")

    filever = downloader.get_episode_list(season_url)
    if not filever:
        die("Impossible de r√©cup√©rer la liste des √©pisodes")

    episodes = downloader.get_anime_episode(season_url, filever)
    if not episodes:
        die("Aucun √©pisode trouv√©")

    # Pr√©parer les informations pour l'historique
    saison = selected_season['name']
    if "saison" not in saison.lower():
        saison = f"Saison {season_index + 1}"

    version_str = "VF" if args.vf else "VOSTFR"
    if version_str.lower() not in saison.lower():
        saison = f"{saison} - {version_str}"

    # R√©cup√©rer les √©pisodes d√©j√† vus
    watched_episodes = get_watched_episodes(anime_name, saison)
    last_watched = get_last_watched_episode(anime_name, saison)

    print(BLUE + f"üé¨ {len(episodes)} √©pisode(s) disponible(s)" + RESET)
    if watched_episodes:
        print(GREEN + f"‚úì {len(watched_episodes)} √©pisode(s) d√©j√† vu(s)" + RESET)

    ep_items = []
    ep_keys = sorted(episodes.keys(), key=lambda x: int(x))

    # Cr√©er la liste avec marqueurs visuels
    for ep_key in ep_keys:
        episode_data = episodes[ep_key]
        ep_num = int(ep_key)

        # Marqueur pour √©pisode vu
        marker = " [D√©j√† VU ‚úì]" if ep_num in watched_episodes else ""

        # Marqueur pour dernier √©pisode vu
        if ep_num == last_watched:
            marker = " [D√©j√† VU ‚úì]"

        if len(episode_data) == 3:
            _, _, episode_name = episode_data
            ep_items.append(f"{episode_name}{marker}")
        else:
            ep_items.append(f"Episode {ep_key}{marker}")

    if args.debug:
        print(f"[DEBUG] Affichage de {len(ep_items)} √©pisodes pour s√©lection")
        print(f"[DEBUG] Premiers 5 √©pisodes: {ep_items[:5]}")

    selected_episode_str = fzf_select(ep_items, "üé¨ S√©lectionner un √©pisode: ")
    if not selected_episode_str:
        die("Aucun √©pisode s√©lectionn√©")

    if args.debug:
        print(f"[DEBUG] Utilisateur a s√©lectionn√©: {selected_episode_str}")

    # Extraction du num√©ro d'√©pisode
    selected_episode_clean = selected_episode_str.replace(" [D√©j√† VU ‚úì]", "").strip()

    # Trouver l'index dans la liste
    try:
        ep_index = ep_items.index(selected_episode_str)
        selected_ep = ep_keys[ep_index]
        if args.debug:
            print(f"[DEBUG] Index trouv√©: {ep_index}, Episode key: {selected_ep}")
    except ValueError:
        # Fallback: extraction par regex
        match = re.search(r'Episode (\d+)', selected_episode_clean)
        if match:
            ep_num = match.group(1)
            if ep_num in episodes:
                selected_ep = ep_num
                ep_index = ep_keys.index(selected_ep)
            else:
                die(f"Episode {ep_num} introuvable")
        else:
            die("Format d'√©pisode invalide")

    video_data = episodes[selected_ep]
    episode_number = int(selected_ep)

    print(CYAN + f"üîÑ Chargement de l'√©pisode {selected_ep}..." + RESET)

    video_url = downloader.get_video_url(video_data)
    if not video_url:
        die("Impossible d'obtenir l'URL vid√©o")

    if video_url.startswith('//'):
        video_url = 'https:' + video_url

    # Mode lien uniquement
    show_link_and_prompt(video_url, anime_name, episode_number, saison, season_url,
                       episodes, ep_keys, ep_index, downloader)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{YELLOW}Interrompu par l'utilisateur{RESET}")
        sys.exit(0)
    except Exception as e:
        die(f"Erreur inattendue: {e}")
